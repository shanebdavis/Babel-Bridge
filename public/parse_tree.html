<html>
<head>
  <link href="./screen.css" rel="stylesheet" type="text/css" />
  <title>Babel-Bridge: Ruby Parsing Expression Grammar Generator</title>
</head>
<body>
<div class="content">
<div class="babel_image">Athanasius Kircher, The Tower of Babel, 1679.</div>
<div class="title_window">
<h1 class="title">Babel Bridge</h1>
<div class="subtitle"><a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar">Memoizing Parsing Expression Grammar</a> generator in Ruby</div>
<div class="nav">
  <a href="index.html">home</a>
  <a href="parsing.html">parsing</a>
  <a href="parse_tree.html" class="selected">parse tree</a>
</div>
</div>


<h1>Parse Tree Class Structure</h1>
<p>Once you are familiar with how to do <a href="parsing.html">basic parsing</a> in
Babel-Bridge, you'll want to do something with the results. The first step is
understanding the parse tree class structure.

<p>Defining a parser automatically generates several classes. For example:
<pre><code><keyword>class</keyword> <identifier>MyParser</identifier> <symbol>&lt;</symbol> <identifier>BabelBridge</identifier><symbol>::</symbol><identifier>Parser</identifier>
  <identifier>rule</identifier> <string>:foo</string><symbol>,</symbol> <string>"foo"</string>
<keyword>end</keyword></code></pre>
<p>Generates:
<pre><code><identifier>MyParser</identifier> <symbol>&lt;</symbol> <identifier>BabelBridge</identifier><symbol>::</symbol><identifier>Parser</identifier>
<identifier>MyParser</identifier><symbol>::</symbol><identifier>FooNode</identifier> <symbol>&lt;</symbol> <identifier>BabelBridge</identifier><symbol>::</symbol><identifier>Node</identifier>
<identifier>MyParser</identifier><symbol>::</symbol><identifier>FooNode1</identifier> <symbol>&lt;</symbol> <identifier>MyParser</identifier><symbol>::</symbol><identifier>FooNode</identifier></code></pre>
<p>FooNode was generated by the :foo rule. It inherits from the BabelBridge::Node
class. FooNode1 represents the first (and only) varient of :foo. FooNode is
never instantiated, but FooNode1 will be created whenever the first varient of
:foo matches.
<p>irb example:
<pre><code><symbol>&gt;</symbol><symbol>&gt;</symbol> <identifier>MyParser</identifier><symbol>.</symbol><identifier>new</identifier><symbol>.</symbol><identifier>parse</identifier><symbol>(</symbol><string>"foo"</string><symbol>).</symbol><keyword>class</keyword>
<symbol>=></symbol> <identifier>MyParser</identifier><symbol>::</symbol><identifier>FooNode1</identifier></code></pre>
<p>You can examine the children of FooNode1 with the matches method:

<pre><code><symbol>&gt;</symbol><symbol>&gt;</symbol> <identifier>MyParser</identifier><symbol>.</symbol><identifier>new</identifier><symbol>.</symbol><identifier>parse</identifier><symbol>(</symbol><string>"foo"</string><symbol>).</symbol><identifier>matches</identifier>
<symbol>=></symbol> <symbol>[</symbol><string>"foo"</string><symbol>]</symbol>
<symbol>&gt;</symbol><symbol>&gt;</symbol> <identifier>MyParser</identifier><symbol>.</symbol><identifier>new</identifier><symbol>.</symbol><identifier>parse</identifier><symbol>(</symbol><string>"foo"</string><symbol>).</symbol><identifier>matches</identifier><symbol>[</symbol><number>0</number><symbol>].</symbol><keyword>class</keyword>
<symbol>=></symbol> <identifier>BabelBridge</identifier><symbol>::</symbol><identifier>TerminalNode</identifier></code></pre>
<p>Let's do a more complex example. Below is a parser that recognizes any
number of non-negative integers concatenated by pluses. Note that the :add rule
has two variants which will create two variant sub-classes, AddNode1 and
AddNode2, of the rule's parse-tree-node class AddNode.</p>

<pre><code><keyword>class</keyword> <identifier>MyMathParser</identifier> <symbol>&lt;</symbol> <identifier>BabelBridge</identifier><symbol>::</symbol><identifier>Parser</identifier>
  <identifier>rule</identifier> <string>:add</string><symbol>,</symbol> <string>:number</string><symbol>,</symbol> <string>"+"</string><symbol>,</symbol> <string>:add</string>
  <identifier>rule</identifier> <string>:add</string><symbol>,</symbol> <string>:number</string>
  <identifier>rule</identifier> <string>:number</string><symbol>,</symbol> <regex>/[0-9]+/</regex>
<keyword>end</keyword>

<identifier>puts</identifier> <identifier>MyMathParser</identifier><symbol>.</symbol><identifier>new</identifier><symbol>.</symbol><identifier>parse</identifier><symbol>(</symbol><string>"34+12"</string><symbol>).</symbol><identifier>inspect</identifier></code></pre>
Running the code above outputs:
<pre><code><identifier>MyMathParser</identifier><symbol>::</symbol><identifier>AddNode1</identifier>
  <identifier>MyMathParser</identifier><symbol>::</symbol><identifier>NumberNode1</identifier> <symbol>&gt;</symbol> <string>"34"</string>
  <string>"+"</string>
  <identifier>MyMathParser</identifier><symbol>::</symbol><identifier>AddNode2</identifier> <symbol>&gt;</symbol> <identifier>MyMathParser</identifier><symbol>::</symbol><identifier>NumberNode1</identifier> <symbol>&gt;</symbol> <string>"11"</string></code></pre>
If you inspect the classes of the child matches of the root AddNode1, you'll get:
<pre><code><symbol>&gt;</symbol><symbol>&gt;</symbol> <identifier>MyMathParser</identifier><symbol>.</symbol><identifier>new</identifier><symbol>.</symbol><identifier>parse</identifier><symbol>(</symbol><string>"34+12"</string><symbol>).</symbol><identifier>matches</identifier><symbol>.</symbol><identifier>collect</identifier> <symbol>{|</symbol><identifier>m</identifier><symbol>|</symbol><identifier>m</identifier><symbol>.</symbol><keyword>class</keyword><symbol>}</symbol>
<symbol>=></symbol> <symbol>[</symbol><identifier>MyMathParser</identifier><symbol>::</symbol><identifier>NumberNode1</identifier><symbol>,</symbol>
    <identifier>BabelBridge</identifier><symbol>::</symbol><identifier>TerminalNode</identifier><symbol>,</symbol>
    <identifier>MyMathParser</identifier><symbol>::</symbol><identifier>AddNode2</identifier><symbol>]</symbol></code></pre>
Every rule consists of one or more pattern elements which must match in order. The index of each pattern element directly corresponds
to the index of it's parse-tree-node in the matches list.

<p>There are several ways to access the children matches of a Node. All of the examples below return the parse-tree-node for the
first number:
<pre><code><comment># returns the first matched pattern-element</comment>
<identifier>MyMathParser</identifier><symbol>.</symbol><identifier>new</identifier><symbol>.</symbol><identifier>parse</identifier><symbol>(</symbol><string>"34+12"</string><symbol>).</symbol><identifier>matches</identifier><symbol>[</symbol><number>0</number><symbol>]</symbol>

<comment># shortcut that also returns the first pattern-element</comment>
<comment># '.matches' is optional</comment>
<comment># Nodes implement Enumerable over their matches</comment>
<identifier>MyMathParser</identifier><symbol>.</symbol><identifier>new</identifier><symbol>.</symbol><identifier>parse</identifier><symbol>(</symbol><string>"34+12"</string><symbol>)[</symbol><number>0</number><symbol>]</symbol>

<comment># matched sub-rules can also be accessed by name</comment>
<identifier>MyMathParser</identifier><symbol>.</symbol><identifier>new</identifier><symbol>.</symbol><identifier>parse</identifier><symbol>(</symbol><string>"34+12"</string><symbol>).</symbol><identifier>number</identifier></code></pre>


<h1>Adding Functionality to the Parse Tree</h1>
<p>Manually walking the parse tree is nice and all, but things really start to get fun when we start adding
some methods to the rule-varient parse-tree-nodes. This is done adding a ruby do-block to the end of a
rule declaration. Inside this do-block you can add anything you want to that rule varient's class definition.

<p>Example:
<pre><code><keyword>class</keyword> <identifier>MyMathParser</identifier> <symbol>&lt;</symbol> <identifier>BabelBridge</identifier><symbol>::</symbol><identifier>Parser</identifier>
  <identifier>rule</identifier> <string>:add</string><symbol>,</symbol> <string>:number</string><symbol>,</symbol> <string>"+"</string><symbol>,</symbol> <string>:add</string> <keyword>do</keyword>
    <keyword>def</keyword> <identifier>result</identifier>
      <identifier>number</identifier><symbol>.</symbol><identifier>result</identifier> <symbol>+</symbol> <identifier>add</identifier><symbol>.</symbol><identifier>result</identifier>
    <keyword>end</keyword>
  <keyword>end</keyword>

  <identifier>rule</identifier> <string>:add</string><symbol>,</symbol> <string>:number</string>
  <identifier>rule</identifier> <string>:number</string><symbol>,</symbol> <regex>/[0-9]+/</regex> <keyword>do</keyword>
    <keyword>def</keyword> <identifier>result</identifier>
      <identifier>to_s</identifier><symbol>.</symbol><identifier>to_i</identifier>
    <keyword>end</keyword>
  <keyword>end</keyword>
<keyword>end</keyword>

<identifier>puts</identifier> <identifier>MyMathParser</identifier><symbol>.</symbol><identifier>new</identifier><symbol>.</symbol><identifier>parse</identifier><symbol>(</symbol><string>"34+12"</string><symbol>).</symbol><identifier>result</identifier>
<comment># outputs "46"</comment></code></pre>
<p>There is a little bit of magic going on here. First, for the first varient of :add (AddNode1), we define a method "result". The result
is just the sum of the results of the left and right-hand-sides of the add operator. We can access the sub-matched parse-tree-nodes by their
rule names - in this case "number" and "add". Then we just recursively call "result" on them and add their return values.
<p>The second bit of magic is in :number's "result" method, we call to_s on self. The to_s method on a Node just returns the string of characters
that rule matched. In this case, a string of digits are returned and calling to_i on them gives us the integer value.
<p>The last bit of magic is we never define a "result" method for the second varient of :add (AddNode2). By convention, if a Node doesn't
know how to respond to a method, it forwards the method call to its first sub-match. In this case, calling "result" on AddNode2 automatically
calls "result" on the sub-matched NumberNode1.

</div>
</body></html>
